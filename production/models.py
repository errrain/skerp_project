from django.db import models, IntegrityError, transaction
from django.conf import settings
from django.utils import timezone
from django.core.exceptions import ValidationError
from datetime import datetime
from zoneinfo import ZoneInfo
import math

# -------------------------------
# Soft Delete Manager / QuerySet
# -------------------------------
class ActiveQuerySet(models.QuerySet):
    def alive(self):
        return self.filter(is_active=True, dlt_yn='N')

class ActiveManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_active=True, dlt_yn='N')


# -------------------------------
# Utility
# -------------------------------
def _ensure_aware(dt):
    """USE_TZ=Trueì¼ ë•Œ naive datetimeì´ë©´ í˜„ìž¬ íƒ€ìž„ì¡´ìœ¼ë¡œ aware ë³€í™˜"""
    if not dt:
        return dt
    if getattr(settings, "USE_TZ", False) and timezone.is_naive(dt):
        return timezone.make_aware(dt, timezone.get_current_timezone())
    return dt

def _today_str():
    """LOT ìƒì„±ì„ ìœ„í•œ 'YYYYMMDD' ë¬¸ìžì—´ ë°˜í™˜"""
    if getattr(settings, "USE_TZ", False):
        now = timezone.now()
        if timezone.is_naive(now):
            now = timezone.make_aware(now, timezone.get_current_timezone())
        today = now.astimezone(timezone.get_current_timezone()).date()
    else:
        tzname = getattr(settings, "TIME_ZONE", "Asia/Seoul")
        today = datetime.now(ZoneInfo(tzname)).date()
    return today.strftime("%Y%m%d")


# -------------------------------
# WorkOrder
# -------------------------------
class WorkOrder(models.Model):
    """
    ìž‘ì—…ì§€ì‹œì„œ í—¤ë” (EA ì¤‘ì‹¬)
    - order_qty: ì´ ì§€ì‹œ ìˆ˜ëŸ‰(EA)
    - LOT ìžë™ë°œê¸‰: JYYYYMMDD-### (ex: J20250905-001)
    - ìƒíƒœ: ëŒ€ê¸°/ì§„í–‰ì¤‘/ìƒì‚°ì™„ë£Œ
    """
    # ì†Œí”„íŠ¸ ì‚­ì œ ê³µí†µ í•„ë“œ
    is_active = models.BooleanField("ì‚¬ìš© ì—¬ë¶€", default=True, db_index=True)
    dlt_yn = models.CharField("ì‚­ì œ ì—¬ë¶€", max_length=1,
                              choices=[('N', 'N'), ('Y', 'Y')],
                              default='N', db_index=True)

    STATUS_CHOICES = [
        ("ëŒ€ê¸°", "ëŒ€ê¸°"),
        ("ì§„í–‰ì¤‘", "ì§„í–‰ì¤‘"),
        ("ìƒì‚°ì™„ë£Œ", "ìƒì‚°ì™„ë£Œ"),
    ]

    # ê¸°ë³¸ ë§¤ë‹ˆì €: ì‚´ì•„ìžˆëŠ” ë°ì´í„°ë§Œ / all_objects: ì „ì²´
    objects = ActiveManager()
    all_objects = models.Manager()

    work_lot = models.CharField("ìž‘ì—… LOT", max_length=20, unique=True, editable=False)

    product = models.ForeignKey(
        "product.Product", on_delete=models.PROTECT, related_name="work_orders"
    )
    customer = models.ForeignKey(
        "vendor.Vendor", on_delete=models.PROTECT, related_name="work_orders"
    )

    order_qty = models.PositiveIntegerField("ì§€ì‹œ ìˆ˜ëŸ‰(EA)")
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default="ëŒ€ê¸°")

    planned_start = models.DateTimeField("ê³„íš ì‹œìž‘", null=True, blank=True)
    planned_end = models.DateTimeField("ê³„íš ì¢…ë£Œ", null=True, blank=True)
    actual_start = models.DateTimeField("ì‹¤ ì‹œìž‘", null=True, blank=True)
    actual_end = models.DateTimeField("ì‹¤ ì¢…ë£Œ", null=True, blank=True)

    remark = models.CharField("ë¹„ê³ ", max_length=200, blank=True)

    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "ìž‘ì—…ì§€ì‹œì„œ"
        verbose_name_plural = "ìž‘ì—…ì§€ì‹œì„œ"

    def __str__(self):
        return f"{self.work_lot} - {self.product.name} ({self.order_qty}EA)"

    # ---------- LOT ì‹œí€€ìŠ¤/ìƒì„± ----------
    def _next_sequence_for(self, yyyymmdd: str) -> int:
        prefix = f"J{yyyymmdd}-"
        existing = WorkOrder.objects.filter(work_lot__startswith=prefix).count()
        return existing + 1

    def _generate_work_lot(self) -> str:
        ymd = _today_str()
        seq = self._next_sequence_for(ymd)
        return f"J{ymd}-{seq:03d}"

    # ---------- ì €ìž¥ ----------
    def save(self, *args, **kwargs):
        self.planned_start = _ensure_aware(self.planned_start)
        self.planned_end = _ensure_aware(self.planned_end)
        self.actual_start = _ensure_aware(self.actual_start)
        self.actual_end = _ensure_aware(self.actual_end)

        if not self.work_lot:
            attempts = 5
            last_err = None
            for _ in range(attempts):
                try:
                    if not self.work_lot:
                        self.work_lot = self._generate_work_lot()
                    with transaction.atomic():
                        return super().save(*args, **kwargs)
                except IntegrityError as e:
                    last_err = e
                    self.work_lot = None
            raise last_err
        else:
            return super().save(*args, **kwargs)

    # ---------- ì†Œí”„íŠ¸ ì‚­ì œ/ë³µêµ¬ ----------
    def soft_delete(self):
        type(self).all_objects.filter(pk=self.pk).update(is_active=False, dlt_yn='Y')
        self.lines.model.all_objects.filter(work_order=self).update(is_active=False, dlt_yn='Y')

    def restore(self):
        type(self).all_objects.filter(pk=self.pk).update(is_active=True, dlt_yn='N')
        self.lines.model.all_objects.filter(work_order=self).update(is_active=True, dlt_yn='N')


# -------------------------------
# WorkOrderLine
# -------------------------------
class WorkOrderLine(models.Model):
    """
    ìž‘ì—…ì§€ì‹œì„œ ìƒì„¸ (ë ‰/í–‰ê±° ë‹¨ìœ„)
    - rack_capacity = product.product_per_rack
    - hanger_capacity = product.rack_per_hanger
    """
    work_order = models.ForeignKey(
        WorkOrder, on_delete=models.CASCADE, related_name="lines"
    )

    # ì†Œí”„íŠ¸ ì‚­ì œ ê³µí†µ í•„ë“œ
    is_active = models.BooleanField("ì‚¬ìš© ì—¬ë¶€", default=True, db_index=True)
    dlt_yn = models.CharField("ì‚­ì œ ì—¬ë¶€", max_length=1,
                              choices=[('N', 'N'), ('Y', 'Y')],
                              default='N', db_index=True)

    # ê¸°ë³¸ ë§¤ë‹ˆì €: ì‚´ì•„ìžˆëŠ” ë°ì´í„°ë§Œ / all_objects: ì „ì²´
    objects = ActiveManager()
    all_objects = models.Manager()

    rack_capacity = models.PositiveIntegerField("1ë ‰ë‹¹ ìˆ˜ìš©ëŸ‰(EA)", null=True, blank=True)
    rack_count = models.PositiveIntegerField("ë ‰ ìˆ˜", default=0)

    hanger_capacity = models.PositiveIntegerField("1í–‰ê±°ë‹¹ ë ‰ ìˆ˜", null=True, blank=True)
    hanger_count = models.PositiveIntegerField("í–‰ê±° ìˆ˜", default=0)

    sequence = models.PositiveIntegerField("ìž‘ì—… ìˆœì„œ", default=1)
    remark = models.CharField("ë¹„ê³ ", max_length=200, blank=True)

    class Meta:
        ordering = ["work_order", "sequence"]
        verbose_name = "ìž‘ì—…ì§€ì‹œì„œ ìƒì„¸"
        verbose_name_plural = "ìž‘ì—…ì§€ì‹œì„œ ìƒì„¸"

    def __str__(self):
        return f"{self.work_order.work_lot} - seq{self.sequence} | {self.rack_count}R / {self.hanger_count}H"

    @property
    def expected_order_qty(self) -> int:
        if not self.rack_capacity or not self.rack_count:
            return 0
        return self.rack_count * self.rack_capacity

    @property
    def required_hanger_count(self) -> int:
        if not self.hanger_capacity:
            return 0
        return math.ceil((self.rack_count or 0) / self.hanger_capacity)

    def clean(self):
        errors = {}

        product = getattr(self.work_order, "product", None)
        if product:
            if self.rack_capacity in (None, 0):
                self.rack_capacity = getattr(product, "product_per_rack", None)
            if self.hanger_capacity in (None, 0):
                self.hanger_capacity = getattr(product, "rack_per_hanger", None)

        if not self.rack_capacity or not self.hanger_capacity:
            errors["rack_capacity"] = "rack_capacityì™€ hanger_capacityê°€ í•„ìš”í•©ë‹ˆë‹¤."

        if self.work_order and self.rack_capacity and self.rack_count is not None:
            expected = self.expected_order_qty
            if expected > 0 and self.work_order.order_qty != expected:
                errors["work_order"] = (
                    f"ì§€ì‹œìˆ˜ëŸ‰({self.work_order.order_qty}) â‰  "
                    f"ë ‰ìˆ˜({self.rack_count}) Ã— ë ‰ë‹¹ìˆ˜ëŸ‰({self.rack_capacity}) = {expected}"
                )

        if self.hanger_capacity and self.hanger_count is not None and self.rack_count is not None:
            if self.hanger_count * self.hanger_capacity < self.rack_count:
                need = self.required_hanger_count
                errors["hanger_count"] = (
                    f"í–‰ê±° ìˆ˜({self.hanger_count}) ë¶€ì¡± â†’ "
                    f"ë ‰ {self.rack_count}ê°œ ìˆ˜ìš©í•˜ë ¤ë©´ ìµœì†Œ {need}í–‰ê±° í•„ìš”"
                )

        if errors:
            raise ValidationError(errors)

class WorkOrderInjectionUsage(models.Model):
    """
    ìž‘ì—… LOT 1ê±´ì— ëŒ€í•´, ì–´ë–¤ ì‚¬ì¶œ ìž…ê³  ë¼ì¸(InjectionReceiptLine)ì„
    ëª‡ ê°œ(used_qty) íˆ¬ìž…í–ˆëŠ”ì§€ ê¸°ë¡í•˜ëŠ” í…Œì´ë¸”
    """
    workorder = models.ForeignKey(
        "WorkOrder",
        on_delete=models.CASCADE,
        related_name="injection_usages",
        verbose_name="ìž‘ì—…ì§€ì‹œ",
    )
    line = models.ForeignKey(
        "purchase.InjectionReceiptLine",
        on_delete=models.PROTECT,
        related_name="workorder_usages",
        verbose_name="ì‚¬ì¶œ ìž…ê³  ë¼ì¸",
    )
    used_qty = models.PositiveIntegerField(default=0, verbose_name="íˆ¬ìž… ìˆ˜ëŸ‰")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "production_workorder_injection_usage"
        unique_together = ("workorder", "line")   # í•œ ìž‘ì—… LOTì— ê°™ì€ ë¼ì¸ ì¤‘ë³µ ë°©ì§€

    def __str__(self):
        return f"{self.workorder.work_lot} â†” {self.line.sub_lot} ({self.used_qty})"

#ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ê¸°ë³¸ ëª¨ë¸
class SparePart(models.Model):
    """
    ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ë§ˆìŠ¤í„°
    - ê¸°ë³¸ì •ë³´: í’ˆëª… / ëª¨ë¸ëª… / ê·œê²© / ë¹„ê³ 
    - ìž¬ê³ ìš”ì•½: í˜„ìž¬ ìˆ˜ëŸ‰ / ìµœê·¼ ìž…ê³ Â·ì¶œê³  ì¼ì‹œ
    - ìž¬ê³ ê¸ˆì•¡: ëª¨ë“  ìž…ê³ ê¸ˆì•¡ í•©ê³„ (ê³„ì‚°ê°’, DB ì»¬ëŸ¼ X)
    """
    # ì†Œí”„íŠ¸ ì‚­ì œ ê³µí†µ í•„ë“œ
    is_active = models.BooleanField("ì‚¬ìš© ì—¬ë¶€", default=True, db_index=True)
    dlt_yn = models.CharField(
        "ì‚­ì œ ì—¬ë¶€",
        max_length=1,
        choices=[("N", "N"), ("Y", "Y")],
        default="N",
        db_index=True,
    )

    objects = ActiveManager()
    all_objects = models.Manager()

    name = models.CharField("í’ˆëª…", max_length=100)
    model_name = models.CharField("ëª¨ë¸ëª…", max_length=100, blank=True)
    spec = models.CharField("ê·œê²©", max_length=200, blank=True)
    remark = models.CharField("ë¹„ê³ ", max_length=100, blank=True)

    current_qty = models.IntegerField("í˜„ìž¬ ìˆ˜ëŸ‰", default=0)
    last_in_at = models.DateTimeField("ìµœê·¼ ìž…ê³ ì¼ì‹œ", null=True, blank=True)
    last_out_at = models.DateTimeField("ìµœê·¼ ì‚¬ìš©ì¼ì‹œ", null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["name"]
        verbose_name = "ìŠ¤íŽ˜ì–´íŒŒíŠ¸"
        verbose_name_plural = "ìŠ¤íŽ˜ì–´íŒŒíŠ¸"

    def __str__(self):
        if self.model_name:
            return f"{self.name} ({self.model_name})"
        return self.name

    @property
    def total_receipt_amount(self):
        """
        ìž¬ê³ ê¸ˆì•¡ = ìž…ê³ ë“±ë¡ ì´ë ¥ì˜ ê¸ˆì•¡ í•©ê³„
        (ì¶œê³ ì™€ëŠ” ë¬´ê´€í•˜ê²Œ, ìˆœìˆ˜ ìž…ê³ ì´ì•¡)
        """
        agg = self.receipts.aggregate(
            total=models.Sum(
                models.F("amount") * models.F("quantity"),
                output_field=models.BigIntegerField(),
            )
        )
        return agg["total"] or 0

    def refresh_stock_summary(self):
        """
        ìž…Â·ì¶œê³  ì´ë ¥ ê¸°ì¤€ìœ¼ë¡œ í˜„ìž¬ ìˆ˜ëŸ‰ / ìµœê·¼ ìž…Â·ì¶œê³  ì¼ì‹œ ìž¬ê³„ì‚°
        """
        in_agg = self.receipts.aggregate(
            total=models.Sum("quantity"),
            last=models.Max("received_at"),
        )
        out_agg = self.usages.aggregate(
            total=models.Sum("quantity"),
            last=models.Max("used_at"),
        )

        total_in = in_agg["total"] or 0
        total_out = out_agg["total"] or 0

        self.current_qty = total_in - total_out
        self.last_in_at = in_agg["last"]
        self.last_out_at = out_agg["last"]
        self.save(update_fields=["current_qty", "last_in_at", "last_out_at"])

#ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ìž…ê³  ì´ë ¥ ëª¨ë¸
class SparePartReceipt(models.Model):
    """
    ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ìž…ê³  ì´ë ¥
    - ìž…ê³ ì¼ì‹œ / ê±°ëž˜ì²˜ / ìˆ˜ëŸ‰ / ê¸ˆì•¡
    """
    spare_part = models.ForeignKey(
        SparePart,
        on_delete=models.CASCADE,
        related_name="receipts",
        verbose_name="ìŠ¤íŽ˜ì–´íŒŒíŠ¸",
    )
    received_at = models.DateTimeField("ìž…ê³ ì¼ì‹œ")
    vendor = models.ForeignKey(
        "vendor.Vendor",
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="spare_part_receipts",
        verbose_name="ê±°ëž˜ì²˜",
    )
    quantity = models.PositiveIntegerField("ìž…ê³  ìˆ˜ëŸ‰", default=0)
    amount = models.PositiveIntegerField("ê¸ˆì•¡", default=0)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-received_at", "-id"]
        verbose_name = "ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ìž…ê³ "
        verbose_name_plural = "ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ìž…ê³ "

    def __str__(self):
        return f"[ìž…ê³ ] {self.spare_part.name} x {self.quantity} ({self.received_at})"


class SparePartUsage(models.Model):
    """
    ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ì‚¬ìš©(ì¶œê³ ) ì´ë ¥
    - ì–¸ì œ / ì–´ë–¤ ê³µì •(ë˜ëŠ” ì„¤ë¹„) ë•Œë¬¸ì— / ì–¼ë§ˆ ì‚¬ìš©í–ˆëŠ”ì§€
    """
    spare_part = models.ForeignKey(
        SparePart,
        on_delete=models.CASCADE,
        related_name="usages",
        verbose_name="ìŠ¤íŽ˜ì–´íŒŒíŠ¸",
    )
    used_at = models.DateTimeField("ì‚¬ìš©ì¼ì‹œ")

    process = models.ForeignKey(
        "process.Process",
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="spare_part_usages",
        verbose_name="ì‚¬ìš©ê³µì •",
    )

    quantity = models.PositiveIntegerField("ì‚¬ìš© ìˆ˜ëŸ‰", default=1)
    reason = models.CharField("ì‚¬ìœ ", max_length=200, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-used_at", "-id"]
        verbose_name = "ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ì‚¬ìš©"
    verbose_name_plural = "ìŠ¤íŽ˜ì–´íŒŒíŠ¸ ì‚¬ìš©"

    def __str__(self):
        return f"[ì‚¬ìš©] {self.spare_part.name} x {self.quantity} ({self.used_at})"


class ChemicalAddition(models.Model):
    """ê³µì •ë³„ ì•½í’ˆ íˆ¬ìž… í—¤ë” (ê³µì •/ì¼ìž/ê·¼ë¬´ì¡° ë‹¨ìœ„)"""

    # ê³µí†µ í”Œëž˜ê·¸ (SparePartì™€ ë™ì¼ íŒ¨í„´)
    is_active = models.BooleanField("ì‚¬ìš© ì—¬ë¶€", default=True, db_index=True)
    dlt_yn = models.CharField(
        "ì‚­ì œ ì—¬ë¶€",
        max_length=1,
        choices=[("N", "N"), ("Y", "Y")],
        default="N",
        db_index=True,
    )

    objects = ActiveManager()
    all_objects = models.Manager()

    process = models.ForeignKey(
        "process.Process",
        on_delete=models.PROTECT,
        related_name="chemical_additions",
        verbose_name="ê³µì •",
    )

    work_date = models.DateField("íˆ¬ìž… ì¼ìž")

    SHIFT_CHOICES = [
        ("DAY", "ì£¼ê°„"),
        ("NIGHT", "ì•¼ê°„"),
    ]
    shift = models.CharField(
        "ê·¼ë¬´ì¡°",
        max_length=10,
        choices=SHIFT_CHOICES,
        default="DAY",
    )

    remark = models.CharField("ë¹„ê³ ", max_length=200, blank=True)

    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name="ë“±ë¡ìž",
    )
    created_at = models.DateTimeField("ë“±ë¡ì¼ì‹œ", auto_now_add=True)

    class Meta:
        db_table = "production_chemical_addition"
        ordering = ["-work_date", "-id"]
        verbose_name = "ì•½í’ˆ íˆ¬ìž… í—¤ë”"
        verbose_name_plural = "ì•½í’ˆ íˆ¬ìž… í—¤ë”"
        unique_together = ("process", "work_date", "shift")

    def __str__(self):
        return f"{self.work_date} {self.get_shift_display()} - {self.process}"

class ChemicalAdditionLine(models.Model):
    """ì•½í’ˆ íˆ¬ìž… ìƒì„¸ (ì–´ë–¤ ì•½í’ˆì„ ì–´ë–¤ ì„¤ë¹„ì— ì–¼ë§ˆë‚˜ ë„£ì—ˆëŠ”ì§€)"""

    addition = models.ForeignKey(
        ChemicalAddition,
        on_delete=models.CASCADE,
        related_name="lines",
        verbose_name="íˆ¬ìž…í—¤ë”",
    )

    chemical = models.ForeignKey(
        "chemical.Chemical",
        on_delete=models.PROTECT,
        related_name="chemical_addition_lines",
        verbose_name="ì•½í’ˆ",
    )

    equipment = models.ForeignKey(
        "equipment.Equipment",
        on_delete=models.PROTECT,
        related_name="chemical_addition_lines",
        verbose_name="íˆ¬ìž…ì„¤ë¹„",
    )

    quantity = models.DecimalField(
        "íˆ¬ìž…ëŸ‰",
        max_digits=10,
        decimal_places=2,  # ì˜ˆ: 600.000 ml ê°™ì€ ê°’
        null=True,  # â† ì¶”ê°€
        blank=True,  # â† ì¶”ê°€
    )
    unit = models.CharField("ë‹¨ìœ„", max_length=10, default="ml")
    remark = models.CharField("ë¹„ê³ ", max_length=200, blank=True)

    created_at = models.DateTimeField("ë“±ë¡ì¼ì‹œ", auto_now_add=True)

    class Meta:
        db_table = "production_chemical_addition_line"
        ordering = ["addition_id", "id"]
        verbose_name = "ì•½í’ˆ íˆ¬ìž… ìƒì„¸"
        verbose_name_plural = "ì•½í’ˆ íˆ¬ìž… ìƒì„¸"

    def __str__(self):
        return f"{self.chemical} / {self.equipment} : {self.quantity}{self.unit}"

class NonFerrousAddition(models.Model):
    """ê³µì •ë³„ ë¹„ì² (Cu/Ni ë“±) íˆ¬ìž… í—¤ë” (ê³µì •/ì¼ìž/ê·¼ë¬´ì¡° ë‹¨ìœ„)"""

    # ê³µí†µ í”Œëž˜ê·¸ (SparePart / ChemicalAddition ê³¼ ë™ì¼ íŒ¨í„´)
    is_active = models.BooleanField("ì‚¬ìš© ì—¬ë¶€", default=True, db_index=True)
    dlt_yn = models.CharField(
        "ì‚­ì œ ì—¬ë¶€",
        max_length=1,
        choices=[("N", "N"), ("Y", "Y")],
        default="N",
        db_index=True,
    )

    objects = ActiveManager()
    all_objects = models.Manager()

    process = models.ForeignKey(
        "process.Process",
        on_delete=models.PROTECT,
        related_name="nonferrous_additions",
        verbose_name="ê³µì •",
    )

    work_date = models.DateField("íˆ¬ìž… ì¼ìž")

    SHIFT_CHOICES = [
        ("DAY", "ì£¼ê°„"),
        ("NIGHT", "ì•¼ê°„"),
    ]
    shift = models.CharField(
        "ê·¼ë¬´ì¡°",
        max_length=10,
        choices=SHIFT_CHOICES,
        default="DAY",
    )

    remark = models.CharField("ë¹„ê³ ", max_length=200, blank=True)

    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name="ë“±ë¡ìž",
    )
    created_at = models.DateTimeField("ë“±ë¡ì¼ì‹œ", auto_now_add=True)

    class Meta:
        db_table = "production_nonferrous_addition"
        ordering = ["-work_date", "-id"]
        verbose_name = "ë¹„ì²  íˆ¬ìž… í—¤ë”"
        verbose_name_plural = "ë¹„ì²  íˆ¬ìž… í—¤ë”"
        # 1ê³µì • / 1ì¼ / 1ê·¼ë¬´ì¡° ë‹¹ ë¹„ì² ì¼ì§€ 1ê±´ë§Œ í—ˆìš©
        unique_together = ("process", "work_date", "shift")

    def __str__(self):
        return f"{self.work_date} {self.get_shift_display()} - {self.process}"

class NonFerrousAdditionLine(models.Model):
    """ë¹„ì²  íˆ¬ìž… ìƒì„¸ (í—¤ë” ì•„ëž˜ ë¹„ì² ë³„ ì‚¬ìš©ëŸ‰)"""

    addition = models.ForeignKey(
        "production.NonFerrousAddition",
        on_delete=models.CASCADE,
        related_name="lines",
        verbose_name="ë¹„ì²  íˆ¬ìž… í—¤ë”",
    )

    # ðŸ”½ ì—¬ê¸°ë¥¼ ì´ë ‡ê²Œ ë³€ê²½
    nonferrous = models.ForeignKey(
        "nonferrous.Chemical",
        on_delete=models.PROTECT,
        verbose_name="ë¹„ì² ",
    )

    # ë‚˜ì¤‘ì— ìš•ì¡°/ë¼ì¸ë³„ë¡œ ìª¼ê°œê³  ì‹¶ì„ ë•Œ ì“¸ ìˆ˜ ìžˆëŠ” ì„ íƒ í•„ë“œ
    group_code = models.CharField(
        "ê·¸ë£¹ì½”ë“œ",
        max_length=20,
        blank=True,
        null=True,
        help_text="í–¥í›„ ìš•ì¡°/ë¼ì¸ êµ¬ë¶„ìš©, í˜„ìž¬ëŠ” ë¯¸ì‚¬ìš©",
    )

    quantity = models.DecimalField(
        "íˆ¬ìž…ëŸ‰",
        max_digits=10,
        decimal_places=2,  # ì˜ˆ: 12.50 kg
    )

    unit = models.CharField("ë‹¨ìœ„", max_length=10, default="kg")
    remark = models.CharField("ë¹„ê³ ", max_length=200, blank=True)

    created_at = models.DateTimeField("ë“±ë¡ì¼ì‹œ", auto_now_add=True)

    class Meta:
        db_table = "production_nonferrous_addition_line"
        ordering = ["addition_id", "id"]
        verbose_name = "ë¹„ì²  íˆ¬ìž… ìƒì„¸"
        verbose_name_plural = "ë¹„ì²  íˆ¬ìž… ìƒì„¸"

    def __str__(self):
        return f"{self.nonferrous} : {self.quantity}{self.unit}"